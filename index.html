<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<link rel="stylesheet" type="text/css" href="styles/stylesheet.css" media="screen">
		<link rel="stylesheet" type="text/css" href="styles/github-light.css" media="screen">
		<link rel="stylesheet" type="text/css" href="styles/print.css" media="print">
		<link rel="stylesheet" type="text/css" href="styles/idea.css">

		<script src="scripts/highlight.pack.js"></script>

		<title>javascript шпаргалка</title>
	</head>

	<body>
		<header>
			<div class="inner">
				<h1>Js-cheatsheet</h1>
				<h2>javascript шпаргалка / введение для начинающих</h2>
			</div>
		</header>

		<div id="content-wrapper">
			<div class="inner clearfix">
				<section id="main-content">

<pre><code class="javascript">//это однострочный комментарий

/*
это
многострочный
*/

//это переменная с именем number, она содержит число 123
var number = 123;
/*в конце каждого выражения обычно ставится ";"
чтобы было понятно, где оно заканчивается*/

/*после объявления переменной дальше в коде можно использовать ее название
почти всюду (почему почти объясню дальше), где нам понадобится число 123. например, в другой переменной*/
var number2 = number;
//после объявления в переменную можно записывать другие значения
number2 = 321.4;

//в названиях переменных, функций и прочего можно использовать буквы, цифры, знаки "$" и "_"
var $a_b1;
//имя не может начинаться с цифры

//в одной строке можно объявить сразу несколько переменных
var v1 = 1, v2 = 2, v3;

//кроме чисел можно использовать булеаны (boolean)
var b1 = true;

//булеан имеет только два возможных значения: true (ИСТИНА) или false (ЛОЖЬ)
//в двоичном коде 1 значит true, 0 - false
//булевские значения можно получить из сравнений некоторых значений
var b2 = 0 < 1; //в переменную b2 запишется true, потому что ноль меньше единицы
//также можно использовать другие операции сравнения
7 > 5 //больше
7 >= 7 //больше или равно
1 <= 3 //меньше или равно
5 == 5 //равно
6 != 7 //неравно
//знак "!" (отрицание) меняет false на true и наоборот
!true == false
! false == true
!(1 < 0) == true

//булеаны можно объединять с помощью операций && (И, AND), || (ИЛИ, OR)
number = 9
1 < number && number != 3 // == true
//единица меньше, чем number, поэтому первая часть (1 < number) даст true
//вместе с этим number не равен 3, поэтому вторая часть (number != 3) тоже будет true
//в итоге (true && true) тоже будет true
/*
&& выдает true, только если справа и слева от него стоят true
*/
true && true == true
true && false == false
false && true == false
false && false == false
/*
|| выдает true, если хотя бы с одной стороны стоит true
*/
true || true == true
true || false == true
false || true == true
false || false == false

//&& приоритетнее, чем ||, поэтому выполняется раньше. так же, как * вычисляется раньше, чем +
true || false && false
//сначала вычислится результат операции И (false && false), получится false
//получится true || false, что будет равно true

//так же, как и для арифметических операций, можно применять скобки
(true || false) && false
//вычислив результат скобок получится
      true      && false
//и в итоге
                   false

//у чисел есть 4 стандартные операции + - / *
-1 / 2 * 3 + 4
//также можно использовать скобки
(1 - 2) * (-3)
//еще есть операция %, которая получает остаток от деления (деление по модулю)
7 % 3 == 1

var n = 1;
//обновление занчения переменной
n = n + 2;
//можно сократить
n += 2;
//это работает со всеми операциями
//в случае n = n + 1 и n = n - 1 можно еще сократить
n--;
n++;
//или
--n; ++n;
var nn = n++; //здесь в nn сохранится значение n,   а значение n увеличится на 1
var mm = ++n; //здесь в mm сохранится значение n+1, а значение n увеличится на 1

//строки (обрамляются в двойные или одинарные кавычки)
var string = "bla";
var str = 'bla bla';
//строки можно сравнивать
"abc" != "abd"
//а также складывать
string + "! " + str == "bla! bla bla"
//у строки можно узнать ее длину
string.length == 3
"aaa".length == 3

//блок кода
{
  //тут какой-то код
  //с отступами относительно фигурных скобок
  //скобки можно не писать, если внутри блока только одно выражение
}
//после закрывающей скобки блока ; не ставится

//условные блоки кода
if (1 < 2) {
  //этот блок отработает, если условие (в этом примере 1 < 2) == true
} else {
  //если условие == false, то отработает этот блок
}
//после if (...) и else и в других похожих случаях ; не ставится, потому что после них идет блок кода

//пример с if
var v = 1; //новая переменная с именем v хранит значение 1
if (v != 1) //если v не равно 1, то
  v = 100; //записываем в него 100
else if (v >= 0) { //иначе если v больше или равно нулю, то
  if (v == 10 || v == 9) //если v равно 10 или 9, то
    v--; //уменьшаем значение v на 1
} else //иначе - это иначе относится к if (v > 0)
    v *= v; //возводим v в квадрат

//в некоторых случаях if можно заменить на конструкцию switch
//например
if (v == 0)
  //...
else if (v == 1)
  //...
else if (v == 2)
  //...
else
  //...
//можно записать как
switch (v) {
  case 0:
    //...
    break;
  case 1:
    //...
    break;
  case 2:
    //...
    break;
  default:
    //...
}
//код после default выполняется, если значение v не совпало ни с одним case'ом
//если не добавлять break, то выполнится код из последующих case'ов. например
switch (v) {
  case 0:
  case 1:
    //...
    break;
}
//аналогичен
if (v == 0 || v == 1)
  //...

//массивы - переменные, которые содержат сразу несколько значений
//пустой массив
var array = [];
//с одним элементом
array = [1];
//с тремя
var a = ["a", "b", "cc"];
//для работы с конкретным элементом массива используется его порядковый номер или индекс, отсчет начинается с 0
a[0] == "a"
a[1] == "b"
a[2] == "cc"

var i = 0;
array[i] = 2;
a[array[i]] == "cc" //i = 0, поэтому array[i] == array[0], поэтому array[i] == 2, поэтому a[array[i]] == a[2]
//как и у строк, у массива можно узнать количество элементов
a.length == 3

//циклы
//цикл while раз за разом выполняет свой блок кода, пока его условие == true
//условие проверяется каждый раз перед выполнением блока
while (1 < 2) {
  //...
}
//блок выше будет выполнятся бесконечно

//пример, в котором все элементы a1, меньшие четырех (то есть 1, 2 и 3), умножаются на 2
var a1 = [1, 2, 3, 4, 5];
var i = 0; //переменная i будет использоваться как индекс массива a1
while (a1[i] < 4) { //пока i-ый элемент массива a1 меньше, чем 4
  a1[i] *= 2; //умножить i-ый элемент на два
  i++; //увеличить индекс на 1
}

//цикл do while похож на обычный while, только условие проверяется после выполнения блока
do {
  //...
} while (1 > 2);
//блок выше выполнится один раз

//цикл for обычно удобнее while
//for(  инициализация;          условие; конец блока)
for (var i = 1, j = 2; i != 10 && j > 1; i++, j += i) {
  //...
}
//его можно переписать с помощью while таким образом
var i = 1, j = 2; //инициализация
while (i != 10 && j > 1) { //условие
  //...
  i++; //конец блока
  j += i;
}
//инициализация, условие и конец блока необязательны. например, можно не добавлять конец блока
//или не добавлять вообще ничего
for (;;) {
  //...
}
//это будет то же самое, что
while (true) {
  //...
}

//для обхода всех элементов массива часто используется такое написание
for (var i = 0; i < array.length; i++) {
  //array[i] будет указывать на очередной элемент массива
}
//или второй вариант - цикл for in
for (var i in array) {
  //array[i]
}

//цикл можно завершить по желанию с помощью инструкции break
while (true) {
  //...
  if (v == 1)
    break;
}

//закончить очередную итерацию блока цикла и перейти к следующей можно с помощью continue
//весь код внутри блока, следующий за continue, не выполнится, если i == 2
for (var i = 0; i < array.length; i++) {
  array[i] *= 2;
  if (i == 2)
    continue;
  array[i] *= 3;
  //здесь все элементы массива будут умножены на 6
  //кроме третьего элемента (у него индекс 2) - он будет умножен только на 2
}

//функции
//объявление функции, принимающей на входе два параметра, i и b (эти названия действуют только внутри функции)
//на выходе она возвращает i в квадрате, если b == true, иначе i в кубе
function name(i, b) {
  if (b)
    return i * i;
  else
    return i * i * i;
}
//после объявления функцию можно вызвать
var r = name(3, true);
r == 9
r = name(2, false);
r == 8

//имена входных параметров и переменные, объявленные внутри, не видны снаружи функции
var ii = 0;
var jj = 1;
function f(ii) {
  ii = 2;
  var jj = 3;
}
f(10); //после вызова f объявленные до нее переменные ii и jj не изменятся

//функции могут использовать внешние переменные, это назвается замыканием
var ex = "!";
function yell(s) {
  return s + ex;
}
yell("hi") == "hi!"

//есть несколько уже написанных функций, которыми можно пользоваться в браузерах
alert(1 + 1); //alert выводит переданное в него сообщение на экран

//функцию можно вызвать, передав не все параметры
function f1(a, b, c) {
  //...
}
f1(1, 2);

//функция может быть анонимной (без имени)
//здесь анонимная функция записывается в переменную fu
var fu = function (a, b) {
  //...
};
//использовать ее можно обычным образом
fu(1, 2);
//именованные функции тоже можно записывать в переменные
var vf = f1;

//функции можно передавать в другие функции
function ff(fi, p) {
  return fi(p);
}
//здесь в параметр fi запишется анонимная функция, которая выводит на экран свой параметр g
ff(function (g) { alert(g); }, 123);

//объекты
//похожи на массивы, только у каждого элемента (который в этом случае называется полем) вместо индекса есть имя
//пустой объект
var o = {};
//объект с одним полем
o = { name: "po" };
//с несколькими полями
o = {
  id: 123,
  action: function(i) { alert(i) } //поле-функция обычно зовется методом
};
//обращаться к полям можно как к элементам массива
o["id"] //123
o["action"](2) //выполнится alert(123)
//или просто через точку
o.action(o.id)
//получение длины строки или массива (a.length) - это тоже обращение к полю
//for in можно использовать для прохода по всем полям объекта
for (var field in o)
  alert(o[field]);

//из поля-функции action можно обратиться к самому объекту с помощью ключевого слова this
o.id = 321;
o.action = function(i) {
  alert(i + this.id); //здесь this указывает на o, то есть this.id == o.id
};

//значение this при вызове функции можно подменять. например
//эта запись
o.action(0);
//аналогична следующей
o.action.call(o, 0);
//значение первого аргумента метода call записывается в this для функции action перед ее выполнением
o.action.call({ id: -1 }, 0); //alert выведет -1, потому что вместо o в this будет записан анонимный объект с id == -1

//у строк, массивов и других объектов есть и другие полезные поля и методы
"abc".charAt(1) == "b" //возвращает символ на позиции 1
"abcd".substring(1, 3) == "bc" //возвращает подстроку от индекса 1 до 3 - 1
//применяет переданную функцию (которая умножает входной параметр на 2) к каждому элементу массива
//и возвращает массив из получившихся элементов
[1, 2, 3].map(function(e) { return e * 2 }) == [2, 4, 6]
//применяет функцию ко всем элементам и возвращает новый массив, в котором только те элементы,
//для которых функция возвратила true
[1, 2, 3].filter(function(e) { return e >= 2 }) == [2, 3]
//еще один простой способ пройти по всем элементам массива
[1, 2, 3].forEach(function(e) {
  //e указывает не очередной элемент, функция вызовется для всех элементов
});

//слово null обозначает отсутствие значения в переменной или в чем-либо
var vvv;
vvv == null //== true
//undefined похоже на null, только обозначает отсутствие самой переменной или поля (точнее имени)
vvv = { pi: 1 };
vvv.mu == undefined //имени mu нет среди полей vvv
//проверку на null или undefined можно сократить
if (vvv.pi != undefined)
  //...
//аналогично
if (vvv.pi)
  //...

//исключения и ошибки
//иногда из-за опечатки или другой причины получается некорректный код
o = { doIt: function() { alert("do it!") } };
o.doId();
//в этом примере ничего не произойдет, потому что в названии вызываемого метода есть опечатка
//весь код после опечатки не заработает
//часто такие ошибки трудно обнаружить. для этого есть блок try
try {
  o = { doIt: function() { alert("do it!") } };
  o.doId();
} catch (ex) {
  alert(ex);
}
//здесь любая ошибка, допущенная внутри try, с именем ex попадет в блок catch,
//и после будет выведена на экран с сообщением "TypeError: o.doid is not a function"
//если все внутри try прошло без ошибок, то блок catch не выполняется

//после try и catch можно добавить блок finally, который выполняется всегда, даже если до него вылезла ошибка
try {
  aleft(123);
} finally {
  //...
}

//у одного try может быть несколько catch
try {
  olert(123);
} catch (e if e instanceof ReferenceError) { //этот блок catch выполнится только при заданном условии
  //здесь ключевое слово instanceof возвращает true если тип ошибки e - это ReferenceError
  alert(e.message);
} catch (e) {
  //...
} finally {
  //...
}

//исключения можно выбрасывать самому с помощью throw
var lt3 = 4;
try {
  if (lt3 >= 3)
    throw (lt3 + " is >= 3!");
  else
    throw "whatever";
} catch (e) {
  alert(e); //выведет сообщение "4 is >= 3!"
}
</code></pre>
				</section>

			</div>
		</div>


		<script>hljs.initHighlightingOnLoad();</script>
	</body>
</html>
